---
name: hdd-cache-ahead
title: cache、先行进位、hdd
date: 2024-09-13
tags:
- cache
- 缓存
- 磁盘
categories:
- 计组

---



## 磁盘

磁道数⇔柱面数

数据传输率 = 单磁道容量 * 转速

单磁盘容量 = 有效盘面数 * 磁道数 * 单磁道容量 

​		   = 有效盘面数 * 磁道数 * 扇区数 * 单扇区容量 

平均读取时间 = 平均寻道时间 + 平均寻找扇区时间（0.5T）+ 其他延迟时间 + 传输时间(比如**读取一个扇区的时间 = 读取一个磁道的时间即1/r / 扇区数**  或者 **1s传20MB，那么读取一个4KB的扇区时间=4K\*1s/20M**)

 寻道时间一般不变，找扇区时间以及传输时间和转速挂钩。

## Cache

主存物理地址

第一块

> 00000000
>
> 00000001
>
> 00000010
>
> 00000011

第二块

> 00000100
>
> 00000101
>
> 00000110
>
> 00000111

前六位是块号，每块有四个地址，所以要用最后2位来表示块内地址（这个单元位于块的哪个部分）高位全部是块号

块内地址位数的确定：必须要直到一个块内有多少个地址，比如说一个块16个字，每个字4 Byte，按字编址就是16个，需要4位表示块内地址，按字节编址就是64个，需要6位来给块内地址

一块就对应cache一行（一块）

一块一块交换，所以最终是要核对cache中的块号。

写回法，CPU将cache作为目标存储器，写完如果脏位有效才写回主存

写通/写穿，CPU将cache和主存同时写入，如果cache不命中就先写完主存，再从主存写cache



主存物理地址 = 标记tag+ cache地址

cache地址 = 行号/组号/无 + 块内地址



cache行内容 = 标记区 + 数据区

cache地址映射表 = cache标记区

cache标记区 = 有效位1bit + 主存标记tag +（脏位(写回策略)1bit + 替换控制位）

cache数据区大小 = 块容量 一块4B......

### 全相联

直接一位一位核对块号（tag） 

优点：存储块可以放到cache的任意一行，空间利用率高

缺点：查找时间可以很长

### 直接映射

指定1行Cache，只能存间隔固定的存储单元，比如第0行cache只能存每一个区的第0块

优点：查找速度快

缺点：存储块只能放到某一个固定的行，空间利用率低

要知道cache的行数，根据行数确定行号占位，然后再核对剩下的tag内容

如果cache共16行，直接节省了16倍的时间 行号占4位

### 组相联

指定某几行Cache，只能存间隔固定的存储单元，比如第0行cache可以存每一个区的第0，2,4，8，是前两种的折中，

如果cache共16行，4路组相联，4个组 组号占2位，节省了4倍时间

先确定组号然后核对tag和有效位，tag匹配，有效位为1即为命中

### 命中率

cache行数128，在主存中有102个字，8字为一个块，重复按照0-101顺序读10次，一下读一个字，命中率？

先到cache里寻找，一定是先核对组号和tag内容，再根据块内地址找，0-101分成13块，第一次先核对tag，没有对的上的，所以只需要13次没命中。

第二次，cache已经写入了102个字的内容，并且分块分组保存，先核对tag中的组号，发现能对的上，然后核对tag，块内地址，算命中。

总命中次数 102*10-13 得命中率为98.7%

## 双重分组跳跃进位加法链 ALU

### 小组内先行进位

已知d3-d0, t3-t0, C~-1~  同时产生C3-C0 DT也能同时产生 耗时2.5t![image-20240711163217501](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240711163217501.png)

缺点：每组要工作都要知道自己的进位输入位，**不能同时知道自己的进位输入位** 

16bit 耗时10t（产生C15-C0的时间）

典型的先行进位4位加法器能够同时产生DT,C3-C0

#### 小组间先行进位

(只要知道组内dt情况就能立即给出DT，C3-C0)

如果能让他们同时知道自己的进位输入位就能节省时间，此时最高位产生的逻辑只需要知道C~-1~ 

已知DT就能马上给出所有最高进位 耗时2.5t ，但是要先得出DT才行，

![image-20240711163153788](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240711163153788-1720686897748-1.png)

16bit 耗时5t（产生C15-C0的时间）

<u>逻辑：同时产生每个组的DT和前三个进位输出，然后再同时产生每个组的最高位进位输出。</u>

同时产生每个组的DT和前三个进位输出，倒是也可以同时产生C3，但是此时C3是根据C~-1~ 产生的，后边的C7C11C15要化成C3的形式才能同时产生，反正都是分两步，索性让他们四个按照相同的逻辑产生。

总结，要让DT起作用，就要先知道DT才行，然后让最高位按照统一的逻辑生成。

#### MSI_ALU

74182(CLA Generator):Cmin，4DT———3Cout ，D*T\* （4个小组）（1个大组） 16bit 

74181(4bit CLA Adder):Cmin，4dt——— Cmax，1DT  （1个小组）4bit 

4*74181+1\*182 = 输入dt，Cmin，到74181和74182，输出D\*T\*，和4个组最终的进位输出

![image-20240711174412643](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240711174412643.png)

74182: 输入Cmin，4D\*T\*，  输出Cmax、 D**T\*\*（4个大组） 64bit

(4*74181+1\*74182)\*4 + 1\*74182 = 64位 三重分组跳跃进位ALU 

## 