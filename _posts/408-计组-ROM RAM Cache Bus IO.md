---
name: ROM-RAM-Cache-Bus
title: ROM RAM Cache IO
date: 2024-09-17
tags:
- cache
- rom/ram
categories:
- 计组

---



![image-20240617152721653](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240617152721653.png)

![image-20240617154333462](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240617154333462.png)

![image-20240617160638666](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240617160638666.png)



# 

## 计算机基本组成

#### 冯诺依曼

==calculator== storage controller I/O

instruction data 同等地位

 

层次化 模块化 明确定义的接口

规则性 容易被重用



取存 加乘 PRINTs STOP

指令格式：操作码+地址码

![image-20240617213301501](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240617213301501.png)

  

#### 存储器

存储单元个数 由MAR决定 存储器地址寄存器，4位能存16个地址

取数指令，运算指令 

![image-20240617214101456](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240617214101456.png)

每个存储单元能够保存的数据长度称为字长，

MAR 4位 能存16个地址

MDR 8位 每个地址能存的字节数

房间号-房间里的床位情况

####  运算器

乘法![image-20240621161144203](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240621161144203.png)

#### 控制器

#### 完成一条指令的过程

取指令，PC储存要执行指令的地址，应支持计数，存到IR，取完自加

分析指令， IR 存放当前执行的指令，OPCODE操作码给到CU

执行指令 操作数的地址

- 程序计数器（PC，Program counter），用于存放指令的地址。为了保证程序(在操作系统中理解为进程)能够连续地执行下去，CPU必须具有某些手段来确定下一条指令的地址。当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到指令寄存器中，此过程称，为“取指令”。与此同时，PC中的地址或自动加1或由转移指针给出下一条指令的地址。此后经过分析指令，执行指令。完成第一条指令的执行，而后根据PC取出第二条指令的地址，如此循环，执行每一条指令。
- 指令寄存器（IR，Instruction Register），用来保存当前正在执行的一条指令。是临时放置从内存里面取得的程序指令的寄存器，用于存放当前从主存储器读出的正在执行的一条指令。当执行一条指令时，先把它从内存取到数据寄存器（DR，Data Register）中，然后再传送至IR。指令划分为操作码和地址码字段，由二进制数字组成。为了执行任何给定的指令，必须对操作码进行测试，以便识别所要求的操作。指令译码器就是做这项工作的。指令寄存器中操作码字段的输出就是指令译码器的输入。操作码一经译码后，即可向操作控制器发出具体操作的特定信号。

#### 主机完成一条指令过程

 ![image-20240621171338162](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240621171338162.png)

#### 计算机性能指标

字长，主频，核数与线程数，指令集执行的时间（静态动态执行频率）

CPI 一条指令所需时钟周期数

IPC 一个时钟周期执行指令数

mips 每秒执行的百万条指令数

flops 每秒浮点运算次数

iops I/O Operations Per Second

## 总线

总线： 各部件共享的传输介质，分时，同一时刻只允许一个

传送方式：串行、并行（距离短）

主设备从设备：有无对总线的控制功能

### 单总线

延宕严重

### 双总线

![image-20240621213833311](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240621213833311.png)

![image-20240621213950031](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240621213950031.png)

![image-20240621221022916](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240621221022916.png)

3. 通信总线

### 总线通信

[同步通信：高度同步，总系长度短](https://blog.csdn.net/iteye_21199/article/details/82200270) 

![image-20240704200733860](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704200733860.png)

不互锁，半互锁，全互锁

![image-20240704200917886](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704200917886.png)

![image-20240704201135928](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704201135928.png)

从设备准备好数据，WAIT才变成高电平

主模块发地址 命令，占用总线

从模块准备数据，**空闲**

从模块向主模块发数据，占用总线



![image-20240704201642697](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704201642697.png)

同步方式，不等对方回答

各模块都有权申请占用总线

从模块变成主模块，发完数据以后再次跟总线断开，总线和原来的主模块连接

充分利用总线带宽

### 总线仲裁

链式查询、计数器定时查询、独立请求

为的是解决多个设备竞争总线控制权

## 存储器

### 分类

#### **存储介质**

**半导体**存储器（TTL MOS）

**磁**表面 (HDD 磁带)

磁芯存储器(Core memory) 电流磁化以后使其极化

**光盘**存储器

#### 存取方式

随机访问，和物理地址无关 RAM 可读写，只读存储器ROM只读

串行访问，磁带，顺序存取，磁盘

#### 地位

主存

- RAM(SRAM,DRAM)
  ROM(MROM,PROM,EPROM,EEPROM)

闪存 缓冲主存和辅存

高速缓冲存储器Cache sram

辅助存储

### 层次结构

速度，价格，容量

存储体系：把两种以上的存储器用软&硬件连接成一个整体

缓存和主存之间要的是速度，硬件支持

![image-20240704203517251](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704203517251.png)

主辅之间要的是容量，软件硬件相结合，虚拟存储，虚地址

### 主存

![image-20240704205102321](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704205102321.png)

GB是千kilo进制 

GiB是千位kilo b**i**nary二进制

计算机一次处理的位数称为字长

16位，1word=16bit=2byte

32位，1word=32bit=4byte

64位，1word=64bit=8byte

字节是计算机处理数据的基本单位，几乎所有计算机操作系统和编程语言都以字节为单位进行数据管理和传输，数据存储是以“字节”（Byte）为单位，数据传输是以大多是以“位”（bit，又名“比特”）为单位，一个位就代表一个0或1（即二进制），每8个位（bit，简写为b）组成一个字节（Byte，简写为B），是最小一级的信息单位。
还可以从以下几个方面来理解：
1.字节(Byte)是电脑中表示信息含义的最小单位，因为在通常情况下一个ACSII码就是一个字节的空间来存放。而事实上电脑中还有比字节更小的单位，因为一个字节是由八个二进制位组成的，换一句话说，每个二进制位所占的空间才是电脑中最小的单位，我们把它称为位，也称比特（bit）。由此可见，一个字节等于八个位。人们之所以把字节称为电脑中表示信息含义的最小单位，表示最基本的字符，是因为一个位并不能表示我们现实生活中的一个相对完整的信息。另外，内存中运算的最小存储单位是字节，位运算也是在一个字节的存储单位的基础上进行的，所以**存储的最小单位可以理解为字节。** 

2.bit是二进制数的一位包含的信息或2个选项中特别指定1个的需要信息量称为一比特，是表示信息的最小单位，只有两种状态：0和1。电脑内部的电路工作有高电平和低电平两种状态.所以就用二进制来表示信号，以便计算机识别。所以计算机能传输的最小单位当然是你信号的单位bit，而不是字节，串口最小也有一位传递的。另外数字信息流的基本单位是bit（比特），时间的基本单位是s（秒），因此bit/s（比特/秒）是描述带宽的单位，1bit/s是带宽的基本单位，所谓的带宽其实指的是传输速度的快慢，也就是指在一个固定的时间内（1秒），能通过的最大位数据。

地址线上是地址信息，一根地址线只能存储2种状态。32根地址线实际上能表示一个32位的二进制数，可以用32个二进制位来表示任意的内存地址或I/O端口地址。

寻址：当CPU**请求数据时获得该数据在内存上的位置的过程**。内存上存储的所有数据都会有一个可以区分的地址，这与其存放的位置相对应，当CPU请求数据时，内存中的电路会根据CPU的地址线上的信号利用数据总线向CPU返回数据。

那么内存是如何编码数据保存的位置的？这里涉及到上文所述的字节的概念。内存每一个存储位置的最小单元都可以储存0或1，即一个位的内容，而内存将8个位设定为一个存储空间的基本单位。而在地址线上每一个地址的编号便对应的是一个存储位置的最小的基本单位。

如何在地址线上用信号表示这个地址，这个问题引出了两个不同的寻址方式：按字节寻址和按字寻址。

如果有30条地址线，一共能表示2^30^ 个字节，能表示2^30^ 

#### 技术指标

容量大小

速度：

- 存取时间t1
  - 访问时间（读出时间，写入时间）
- 存取周期t2
  - 连续 两次 独立 的存储器操作
  - 读或者写最小的时间间隔

t1<t2

带宽 bps

#### 半导体存储芯片

![image-20240704214511866](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704214511866.png)

4条数据线意味着每个内存单元可以存储4个数据位（通常是4比特）。这意味着每个内存单元可以存储 24=162^4 = 1624=16 个不同的数据值。

| 地址线（单向） | 数据线（双向） | 芯片容量  |
| -------------- | -------------- | --------- |
| 10             | 4              | 1K*4bit   |
| 14             | 1              | 16K*1 bit |
|                |                |           |

内存条上有很多芯片，不同的地址范围选的芯片也不一样 ，还有读写控制线

![image-20240704215706473](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704215706473.png)

##### 译码驱动

![image-20240704220128452](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704220128452.png)

4位地址，共16个单元，8条控制线，一个单元是8位，所以存储空间是一个16*8位的矩阵，简单

0000 字线0号激活，0,0~0,7

缺点：线路密集

20个地址线，输出1M条线，

![image-20240704220753043](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704220753043.png)

只有两边同时激活才能进行数据的输出，20个地址线，译码器输出只用2K条线。

#### RAM 随机存取

##### SRAM 

保存0-1的原理：用双稳态触发器

六管静态RAM

##### ![image-20240704221726015](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704221726015.png)

给出行选信号，列选信号，读有效

T6 T8 然后读出

![image-20240704222330938](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704222330938.png)

Intel 2114 读

![image-20240704223228647](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704223228647.png)

##### DRAM

保存0-1:电容（需要刷新）

![image-20240704224121714](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704224121714.png)

![image-20240704224306390](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704224306390.png)

刷新放大器对电容充电

放大器能够放大电容的电平

刷新和行地址有关，列地址无关

![image-20240704225313098](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704225313098.png)

![image-20240704225840140](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704225840140.png)

刷新安排再指令译码阶段

##### SRAM VS DRAM

|          | DRAM（主存）     | SRAM（Cache） |
| -------- | ---------------- | ------------- |
| 存储原理 | 电容             | 触发器        |
| 集成度   | 低               | 高            |
| 芯片引脚 | 少（行列分别传） | 多            |
| 功耗     | 少               | 多            |
| 价格     | 低               | 高            |
| 刷新     | 有               | 无            |
| 速度     | 慢               | 快            |

#### ROM 只读存储器

MROM 掩膜ROM Uncustomizable

交叉处有无MOS管 有1无0

PROM 一次性编程 破坏性编程

![image-20240704230627923](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704230627923.png)

EPROM 多次 紫外线擦写

![image-20240704230734230](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704230734230.png)

EEPROM 支持局部擦写

FlashMemory 

#### 存储器与CPU连接

##### 容量扩展

![image-20240704231244644](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704231244644.png)

两个芯片共用地址线，输入1个十位的地址，2114内相同的地址单元能够同时各自输出自己储存的4位信息，重点：**同时工作** 片选同时激活

![image-20240704231832857](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704231832857.png)

11根地址线，多出来的一条用于控制片选，原来10根地址线共用，地址线的目的：每一个二进制数都要表示一个不同的存储单元 片选不同时工作

![image-20240704232318234](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704232318234.png)

原来10根地址线共用

##### 连接存储器与CPU

写出二进制地址码，确认芯片数量和类型，分配地址线，确定片选信号逻辑

![image-20240705131119849](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705131119849.png)

CPU-16根地址线-8根数据线

6000H 67FF为系统程序区 2K*8 11根 ROM

6800H 6BFFH为用户程序区 1K*8 10根 RAM

ROM选择2K*8 RAM选择1K\*4的两个存储器进行位扩展

A10-A0 连接ROM A9-A0连接RAM

A13-A11 连接138 译码信号连到片选上 100-ROM 101-RAM 

A14连到138的G1 A15连接到G2a

MREQ低电平访存控制信号连到G2b

（CPU访问内存，译码器必须工作）

地址要全部用上

![image-20240705131919043](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705131919043.png)

注意看 ROM2K空间利用充分，但是Y5和A10同时=0才算RAM空间

![image-20240705131758051](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705131758051.png)

![image-20240705135723021](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705135723021.png)

![image-20240705135733548](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705135733548.png)![image-20240705135742847](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705135742847.png)

错误处理

![image-20240705212942601](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705212942601.png)

低位交叉

![image-20240705213711855](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705213711855.png)

看清，是几体并行，4体并行就是低2位为译码器输入。

要求32K * 8 bit 给了4K * 4 bit的芯片 ， 低位交叉四体并行

4K 共12位地址线 需要芯片共16片，一般的做法是用2片4K*4进行位扩展，用8个这样的组合进行字扩展，高3位接译码器，但由于是要求低位4体并行的交叉编址，先用2片4K\*4进行位扩展，然后用两组进行字扩展，最后用4个这样的组合进行字扩展。低2位接译码器

读写信号、MREQ、数据输出位D、地址线、片选使能（位扩展使能统一，字扩展看译码器输出）

##### 存储器校验

检测与纠错能力

###### 前导：奇偶校验

- **奇校验**：如果数据单元中1的数量已经是奇数，则校验位设置为0；否则，校验位设置为1。如果出现错误，1的个数不再是奇数。

  - 假设数据单元为8位，并且使用奇校验：
  - 数据 `10110011` 中有5个1，因此符合奇数要求，校验位为0。
  - 数据 `11001010` 中有4个1，不符合奇数要求，校验位为1。

- **偶校验**：如果数据单元中1的数量已经是偶数，则校验位设置为0；否则，校验位设置为1。如果出现错误，1的个数不再是偶数。

- **校验过程**

  发送方在数据末尾添加校验位，形成校验单元后发送。接收方收到数据后，重新计算校验位，并与接收到的校验位进行比对。如果两者相同，则认为数据传输正确；如果不同，则意味着在传输过程中出现了错误。



2^k^≥n+k+1

K是纠错码位数，一共有2^k^种错误，

一位错，n+k+1

合法代码

![image-20240705140417990](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705140417990.png)

 编码最小距离：任意两个合法代码二进制位的最少差异数

L-1 = D+C

Length Detected Correction

[汉明码使用](https://blog.csdn.net/a493823882/article/details/109343791) 校验位错了不用纠

#### 提高访存速度

高速器件、层次结构(Cache)、**调整主存结构**

##### 单体多字系统

![image-20240705210133859](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705210133859.png)

数据不连续会影响效率，4个字一起出来

##### 多体并行

**高位交叉**，

数据组织特点：相邻地址的数据处于同一存储体,一个地址寄存器,多模块串行（局部性原理）,性能无提升,扩充容量方便

![image-20240705210318229](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705210318229.png)

![b5ecff2b7ba843538f083126dfe59653](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/b5ecff2b7ba843538f083126dfe59653-1720187489744-3.png)

**低位交叉**，如果采用分时启动的方法，可以在不改变每个存储体存取周期的前提下，提高整个主存的速度

![image-20240705210508945](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705210508945.png)

![image-20240705210704163](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705210704163.png)

![96e598788488485e97a03a8ff2059885](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/96e598788488485e97a03a8ff2059885-1720187482260-1.png)

每个存储体均需地址寄存器,模M编址方式 多模块并行（局部性原理）,扩充容量也方便

低位交叉的好处：如果要连续读取，同一个访问周期内，存储器是不能进行下一步读取的，高位交叉会让同一个存储器占用过高，其他用不上，低位就解决了这个问题,流水线访问

##### 存储芯片

SDRAM 同步DRAM

RDRAM 解决带宽问题

Cache DRAM DRAM访问过的行存入cache 下一次先和这个行地址比较，一样的话直接把列地址输入cache 有利于猝发读取

### 辅存

![image-20240704232924331](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704232924331.png)

![image-20240704233315282](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704233315282.png)

![image-20240704233745159](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704233745159.png)

### Cache 

高速缓冲存储器，避免CPU空等现象

#### 程序访问的局部性原理

时间的局部性：当前的数据，过一会还会用

空间的局部性：当前的数据，相邻的数据也会用

#### 工作原理

![image-20240705224559514](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705224559514.png)

按照块进行传送。 M>>C

命中：主存快调入缓存

命中率：与cache容量和块长有关

访问效率：

$e=\frac{访问\text{Cache时间}}{平均访问时间}$

![image-20240705225126490](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705225126490.png)

#### 基本结构

![image-20240705225727823](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705225727823.png)

#### 读写操作

![image-20240705225811853](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705225811853.png)

![image-20240705225941275](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705225941275.png)

#### 改进

L1 L2 L3缓存

分离缓存 指令数据分离，冯氏结构统一

#### Cache-主存的地址映射

方式和级数有关

##### 直接映射

xx**x只能装到cache的某一确定**的位置，即使Cache的其他许多地址空着也不能占用，这使得直接映射的块冲突概率最高，空间利用率最低。vmax

![image-20240705230901918](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705230901918.png)

主存块号的低𝑐位正好是它要装入的Cache行号。给每个Cache行设置一个长为𝑡=𝑚−𝑐的标记(tag),当主存某块替换进Cache后，就将其块号标记位设置在对应Cache行的标记中

##### 全相联映射

主存中的每一块可以装入Cache 中的**任何**位置，每行的标记用于指出该行取自主存的哪一块，所以CPU访存时需要与所有Cache行的标记进行比较。全相联映射方式的优点是比较灵活，Cache 块的冲突概率低，空间利用率高，命中率也高;缺点是标记的比较速度较慢，实现成本较高，通常需采用昂贵的按内容寻址的相联存储器进行地址映射 vmin

##### **组相联映射**

**组内全相联 组外直接映射**

确定组号之后再确定区号，0和2^c-r^ 2^c-r+1^ 都在第0组，组内采用字块号一一对应的方法![20210713154218](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/20210713154218.png)

#### 替换算法

Cache满就要替换栈

##### FIFO(First in first out)

先进先出，违反程序局部性原则

##### LRU(Last recently used)

近期最少使用

## I/O 

### 概况

早期：分散连接，串行工作

接口模块和DMA阶段：总线连接，并行工作（中断/DMA）

通道结构阶段：有自己的简单处理器

I/O处理机阶段：高性能微处理器

### 组成

#### 软件

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705235621421.png" alt="image-20240705235621421"  />

#### 硬件

接口\设备

#### 外部设备

![image-20240706002820937](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706002820937.png)

键盘鼠标显示器，A/D D/A 模数转换，终端，汉字处理。

#### I/O接口

选择设备，数据缓冲匹配速度，串并格式转换，电平转换，传送命令

![image-20240706121949206](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706121949206.png)

![image-20240706122640491](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706122640491.png)

### 主机与I/O的联系方式

![image-20240705235948953](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705235948953.png)

![image-20240706000234331](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706000234331.png)

 (3)必须要有统一的时间标准

![image-20240706000359748](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706000359748.png)

### 主机与I/O的信息传送控制

#### 通道方式、IO处理器方式

#### 程序查询方式

![image-20240706000830237](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706000830237.png)

完全由主机执行程序实现，等待数据准备的过程CPU会空转，一直查询状态，串行工作

查询的程序嵌入CPU

![image-20240706140313041](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706140313041.png)

![image-20240706142641037](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706142641037.png)



#### 程序中断方式

![image-20240706001125217](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706001125217.png)

会暂停现行程序 ，部分并行工作。中断会影响正常的程序处理，为了恢复CPU仍然要消耗资源，执行中断服务程序

##### I/O形成中断请求过程

![image-20240706001442993](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706001442993.png)

![image-20240706141207557](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706141207557.png)

1. 中断请求触发器+中断屏蔽触发器

先决条件：MASK = 0 中断未被屏蔽 + 设备本身已经准备好数据了 -> INTR = 1 设备发出中断请求  

![image-20240706141710467](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706141710467.png)

2. 排队器

分为**软件**和**硬件**方式

硬件：链式排队器

优先级最高的没有请求，$\overline {INTP'}$=1，$\overline {INTR}$=1，会导致这些优先级高、无请求的$\overline {INTP'}$=1，低优先级的来了请求，$\overline {INTR}$=0，就会让之后的$\overline {INTP'}$=0, 此时之后的$\overline {INTP'}$都对之后的与非门起了决定性作用，也就是优先级更低的全部禁用。

![image-20240706145002524](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706145002524.png)

$\overline {INTP'}$，$ {INTR}$全部为1才能发出真正的中断指令INTP

3. 中断向量地址形成部件（编码器）

不同的设备中断服务程序不同，每一个服务程序都有一个入口地址，CPU要找到这些入口就必须对这些地址进行编码，输入是经过排队器综合以后的中断信号INTP，输出是中断向量（二进制码）仅仅是就这些输入编的码，还要将中断向量地址和存储的中断对应设备的服务程序一一对应，中断向量地址处保存的是服务程序的入口地址的地址

![image-20240706154548716](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706154548716.png)

4. 接口电路

![image-20240706154757761](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706154757761.png)

##### 中断执行过程

![image-20240706161105095](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706161105095.png)

![image-20240706212237016](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706212237016.png)

中断请求、中断判优、中断响应、中断服务、中断返回

CPU会在统一的时间，即每条指令执行阶段的最后时刻，进行**中断查询**

设备只要准备好了(D=1)并且没有被屏蔽(MASK=0)，查询信号(相当于D触发器的clk信号)就会使得输出INTR=1，此时请求INTR=1也会被送到排队器进行**判优**，

随后CPU根据判优结果进行响应，如果排队选中并且EINT=1，进行CPU的**中断响应** 

- 响应条件
  - 中断源有中断请求, INTR=1 
  - 开中断，使 EINT=1
  - 一条指令执行完毕，且没有更紧迫的任务

通过INTR信号线发出的外中断是可屏蔽中断 ，在关中断（EINT=0）的情况下不会被响应

I/O设备的就绪时间是随机的，而CPU在统一的时刻即每条指令执行阶段结束前向接口发出中断查询信号，以获取I/O 的中断请求，也就是说，CPU响应中断的时间是在每条指令执行阶段的结束时刻。这里说的中断仅指外中断，内中断不属于此类情况。

**响应**时，先由INTA~cknowledge~=1激活设备编码器：将排队结果发到编码器，生成向量地址，向量本身是JMP TO  200, 向量地址是JMP TO 200 的地址

根据向量地址进行开始**运行服务程序** 

![image-20240706170143933](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706170143933.png)

多重中断的流程

![image-20240706172054097](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706172054097.png)

1-3由隐指令完成，单重中断：直到恢复完现场才开中断。多重中断允许嵌套，必须满足下列条件:①在中断服务程序中提前设置开中断②优先级别高的中断源有权中断优先级别低的中断源。

假如D>A>C>B，源A执行中，D来了就要中断A去执行D。每个中断源都有一个 屏蔽触发器屏蔽触发器 ，1 表示 屏蔽该中断源屏蔽该中断源 的请求，0 表示可以 正常申请正常申请 ，所有屏蔽触发器组合在一起便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字。D的屏蔽字是1111，具有最高优先级，A是1110次之，以此类推

![image-20240706170847647](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706170847647.png)

![image-20240706171244016](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706171244016.png)![image-20240706171245893](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706171245893.png)

屏蔽技术

屏蔽触发器和屏蔽字：程序中断接口电路中，完成触发器D，中断请求触发器INTR和屏蔽触发器MASK。

当中断源被屏蔽时（MASK=1），此时即使D=1，中断查询信号到来时刻只能将INTR置“0”，CPU接收不到该中断源的中断请求，即它被屏蔽。

若该中断源未被屏蔽（MASK=0）当设备工作已完成时（D=1），中断查询信号则将INTR置“1”，表示该中断源向CPU发出中断请求，该信号送至排队器进行优先级判断。显然，对于每个中断请求触发器就有一个**屏蔽触发器**，将所有屏蔽触发器组合在一起，便构成了一个**屏蔽寄存器**。屏蔽寄存器的内容称为**屏蔽字**。屏蔽字与中断源的优先级是一一对应的。

屏蔽技术可改变优先等级：严格地说，优先级包含**响应优先级**和**处理优先级**。响应优先级是指CPU响应各中断源请求的优先次序，这种次序往往是硬件线路已设置好的，不便于改动。处理优先级是指CPU实际对各中断源请求的处理优先次序。如果不采用屏蔽技术，响应的优先次序就是处理的优先次序。

eg. 响应L1>L2>L3>L4 处理反过来

几个中断源同时提出中断请求，L1首先响应，开始执行，但是被L2打断，L2开始执行，被L3打断，之后L3被L4打断，L4执行完继续执行L3



ABCD由设备识别电路，A能将

#### DMA方式

**I/O direct to Memory**

**D**irect **M**emory **A**ccess

##### DMA方式的特点

- 在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。

- 主存中要开辟专用缓冲区，及时供给和接收外设的数据。

###### 数据通路

![image-20240706172851691](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706172851691.png)

CPU不参与

###### 与主存交换数据方式

1. 停止CPU对主存的访问。不能充分发挥CPU对主存的利用率。![image-20240706173212015](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706173212015.png)

2. 窃取周期。存取周期内CPU不能通过总线对内存进行访问，然而CPU指令执行并不是一条条取的，而是预取。并行工作。

   CPU未占用总线,DMA/CPU正在占用总线,CPU/DMA、CPU同时发起占用总线的请求，DMA![image-20240706174016933](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706174016933.png)

3. 交替访问 一个原周期分为DMA周期和CPU周期![image-20240706173952420](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706173952420.png)

##### 接口/DMA控制器

###### 功能

DMA申请总线控制权/CPU移交总线控制权/DMA管理总线控制传输数据, 确定数据传送首地址和长度, 对传输过程中的数据进行修正/DMA发出操作完成信号

###### 组成

<u>字</u>计数器**W**ord**C**ounter

<u>主存地址</u>寄存器**A**ddress**R**egister

<u>数据缓冲</u>寄存器**B**uffer**R**egister

![image-20240706180228563](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706180228563.png)

##### 传输过程

![image-20240706180723685](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706180723685-1720260754514-3.png)

###### 预处理

预处理就是CPU的I/O指令

CPU完成准备工作：首先，CPU执行几条I/O 指令，用以测试I/O设备状态，向 DMA 控制器的有关寄存器置初值、设置传送方向、启动该设备等。然后，CPU继续执行原来的程序，直到I/O设备准备好发送的数据（输入情况）或接收的数据（输出情况）时，I/O设备向DMA控制器发送DMA请求，再由DMA控制器向CPU 发送总线请求（有时将这两个过程统称为DMA请求），用以传输数据。

###### 数据传送

传输可以用byte/word为基本单位，也可用block作为基本单位，对于以数据块为单位的传送（如硬盘），DMA占用总线后的数据输入和输出操作都是通过循环来实现的。需要指出的是，这一循环也是由 DMA 控制器（而非通过CPU执行程序）实现的，即数据传送阶段完全由DMA（硬件）控制。

![image-20240706181444755](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706181444755.png)

![image-20240706181559135](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706181559135.png)

WC(Word Counter)溢出会发中断请求INTR给中断机构

###### 后处理

DMA控制器向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理，包括**<u>校验</u>送入主存的数据是否正确**、测试传送过程中是否出错（错误则转入诊断程序）及决定是否继续使用DMA传送其他数据块等，**由中断服务程序完成** 

##### DMA和系统连接方式

公共总线 串联

独立DMA请求 并联

##### DMA接口类型

![image-20240706183458104](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706183458104.png)

![image-20240706183609988](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706183609988.png)

优先级：速度优先

![image-20240706184002042](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706184002042.png)



#### 三种方式辨析

![image-20240706001545500](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706001545500.png)

##### DMA方式和中断方式的区别

1. 中断方式是程序的切换，需要保护和恢复现场;而DMA方式除了预处理和后处理，其他时候不占用CPU的任何资源。
2. 对中断请求的响应只能发生在每条指令执行完毕时（即指令的执行周期后）;而对DMA请求的响应可以发生在每个机器周期结束时（存储周期、取指周期、间址周期、执行周期后均可），只要CPU不占用总线就可被响应。
3. 中断传送过程需要CPU的干预;而 DMA传送过程不需要CPU 的干预，因此数据传输率非常高，适合于高速外设的成组数据传送。
4. DMA请求的优先级高于中断请求。
5. 中断方式的中断请求以传送数据的方式，DMA是以后处理的方式
6. 中断方式具有对异常事件的处理能力，而DMA方式仅局限于传送数据块的I/O操作。
7. 从数据传送来看，中断方式靠程序传送，DMA方式靠硬件传送。

#### 易混淆点

向量中断、中断向量、向量地址

- 向量中断：用来识别中断源的方式，能够找到对应的中断服务程序的入口地址，即向量地址
- 向量地址：向量表中每一项的地址，中断服务程序的入口地址
- 中断服务程序：中断源对应的处理程序
- 中断向量：中断服务程序的入口地址/中断服务程序的跳转指令
- 中断向量地址：中断向量的地址

中断服务程序、子程序

- 中断服务程序：时间不固定，跟主程序无关，需要另外的硬件电路，嵌套级数完全由中断优先级来决定
- 子程序：时间固定可预知，和主程序息息相关，为主程序服务，不需要额外硬件，嵌套级数由内存堆栈大小限制决定

中断响应优先级、中断处理优先级

- 中断响应优先级：由硬件排队器或中断查询程序的查询顺序决定
- 中断处理优先级：由中断屏蔽字来改变，反映的是正在处理的中断是否比新发生的中断的处理优先级低（屏蔽位为“0”，对新中断开放），若是，则中止正在处理的中断，转到新中断去处理，处理完后再回到刚才被中止的中断继续处理。

### 